import hashlib
import base64
from Crypto.Util.number import isPrime, inverse
from Crypto.PublicKey import RSA
from Crypto.Signature import pkcs1_15
from Crypto.Hash import SHA256

def get_next_prime(n):
    # Лог говорит "checking consecutive integers"
    while not isPrime(n):
        n += 1
    return n

def solve(variant_q):
    username = "admin"
    seed = f"{username}_lovenote_2026_valentine".encode()

    # Находим p (всегда одинаково)
    p_hash = hashlib.sha256(seed).digest()
    p = get_next_prime(int.from_bytes(p_hash, 'big'))

    # Находим q (варианты интерпретации лога)
    if variant_q == 1:
        # Вариант 1: H(H(seed + "pki")) - бинарно
        mid = hashlib.sha256(seed + b"pki").digest()
        q_hash = hashlib.sha256(mid).digest()
    else:
        # Вариант 2: H(Hex(H(seed + "pki"))) - через строку
        mid_hex = hashlib.sha256(seed + b"pki").hexdigest().encode()
        q_hash = hashlib.sha256(mid_hex).digest()

    q = get_next_prime(int.from_bytes(q_hash, 'big'))

    # Сборка ключа
    n = p * q
    e = 65537
    d = inverse(e, (p - 1) * (q - 1))
    key = RSA.construct((n, e, d, p, q))

    # Подпись
    msg = "give_me_flag" #
    h = SHA256.new(msg.encode())
    return pkcs1_15.new(key).sign(h).hex()

print(f"ПОДПИСЬ (Вариант 1): {solve(1)}")
print(f"ПОДПИСЬ (Вариант 2): {solve(2)}")
