import hashlib
from Crypto.Util.number import bytes_to_long, inverse
from Crypto.PublicKey import RSA

# Твой юзернейм для тестов
TEST_USER = "asdasdasdsada"

def get_next_prime(n):
    if n % 2 == 0: n += 1
    while True:
        if is_prime(n): return n
        n += 2

def is_prime(n, k=40):
    if n == 2: return True
    if n % 2 == 0: return False
    r, s = 0, n - 1
    while s % 2 == 0:
        r += 1
        s //= 2
    for _ in range(k):
        a = pow(2, s, n)
        if a == 1 or a == n - 1: continue
        for _ in range(r - 1):
            a = pow(a, 2, n)
            if a == n - 1: break
        else: return False
    return True

def generate_key(username, double_hash_q=False):
    seed_str = f"{username}_lovenote_2026_valentine"
    seed_bytes = seed_str.encode()
    
    # 1. P (всегда одинаково)
    hash_p = hashlib.sha256(seed_bytes).digest()
    p = get_next_prime(bytes_to_long(hash_p))
    
    # 2. Q (два варианта из логов)
    # Вариант А: Один раз хешируем (seed + pki)
    modified_seed = hashlib.sha256(seed_bytes + b"pki").digest()
    
    if double_hash_q:
        # Вариант Б: Хешируем результат еще раз ("Hashing modified seed")
        final_hash_q = hashlib.sha256(modified_seed).digest()
    else:
        final_hash_q = modified_seed

    q = get_next_prime(bytes_to_long(final_hash_q))
    
    n = p * q
    e = 65537
    phi = (p - 1) * (q - 1)
    d = inverse(e, phi)
    return RSA.construct((n, e, d, p, q))

print(f"--- КАЛИБРОВКА ДЛЯ ЮЗЕРА: {TEST_USER} ---\n")

# Вариант 1
key1 = generate_key(TEST_USER, double_hash_q=False)
print(f"[ВАРИАНТ 1 - Обычный хеш]")
print(f"Первые символы ключа: {key1.export_key().decode()[:50]}...")
print(f"Modulus (n) начинается с: {str(key1.n)[:10]}...\n")

# Вариант 2
key2 = generate_key(TEST_USER, double_hash_q=True)
print(f"[ВАРИАНТ 2 - Двойной хеш]")
print(f"Первые символы ключа: {key2.export_key().decode()[:50]}...")
print(f"Modulus (n) начинается с: {str(key2.n)[:10]}...")
