import hashlib

def is_prime(n):
    """Проверка числа на простоту."""
    if n < 2: return False
    if n == 2 or n == 3: return True
    if n % 2 == 0: return False
    for i in range(3, int(n**0.5) + 1, 2):
        if n % i == 0: return False
    return True

def find_next_prime(n):
    """Ищет первое простое число, начиная с n (как в логах)."""
    while not is_prime(n):
        n += 1
    return n

# Данные для генерации
username = "admin"
message = "1234"
seed_pattern = f"{username}_lovenote_2026_valentine"

# 1. Генерация P (Prime derivation step 1)
hash_p = hashlib.sha256(seed_pattern.encode()).digest()
p = find_next_prime(int.from_bytes(hash_p, 'big'))

# 2. Генерация Q (Prime derivation step 2)
# В логах: SHA256(seed + b"pki")
hash_q = hashlib.sha256(seed_pattern.encode() + b"pki").digest()
q = find_next_prime(int.from_bytes(hash_q, 'big'))

# 3. RSA параметры
n = p * q
phi = (p - 1) * (q - 1)
e = 65537
d = pow(e, -1, phi) # Приватный ключ

# 4. Создание подписи
# Хэшируем сообщение "1234" (SHA-256)
msg_hash = hashlib.sha256(message.encode()).digest()
msg_int = int.from_bytes(msg_hash, 'big')

# Подписываем: S = H^d mod n
signature_int = pow(msg_int, d, n)

# Переводим в HEX для формы
signature_hex = hex(signature_int)[2:]
print(f"--- Результаты для {username} ---")
print(f"Сообщение: {message}")
print(f"Сигнатура (HEX):\n{signature_hex}")
