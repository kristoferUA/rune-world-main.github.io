import hashlib
import random

def is_prime(n, k=40):
    """Быстрая проверка на простоту Миллера — Рабина."""
    if n <= 1: return False
    if n <= 3: return True
    if n % 2 == 0: return False
    r, d = 0, n - 1
    while d % 2 == 0:
        r += 1
        d //= 2
    for _ in range(k):
        a = random.randint(2, n - 2)
        x = pow(a, d, n)
        if x == 1 or x == n - 1:
            continue
        for _ in range(r - 1):
            x = pow(x, 2, n)
            if x == n - 1:
                break
        else:
            return False
    return True

def find_next_prime(n):
    """Ищет следующее простое число (как в логах)."""
    if n % 2 == 0: n += 1
    while not is_prime(n):
        n += 2
    return n

# Данные для генерации
username = "admin"
message = "1234"
seed_pattern = f"{username}_lovenote_2026_valentine".encode()

# Шаг 1: Находим p
h_p = hashlib.sha256(seed_pattern).digest()
p = find_next_prime(int.from_bytes(h_p, 'big'))

# Шаг 2: Находим q (Seed + b"pki")
# Лог: Modifying seed with PKI-related constant (SHA256(seed + b"pki"))
# Затем: Hashing modified seed with SHA256
pki_const = hashlib.sha256(seed_pattern + b"pki").digest()
h_q = hashlib.sha256(pki_const).digest() 
q = find_next_prime(int.from_bytes(h_q, 'big'))

# Шаг 3: RSA параметры
n = p * q
phi = (p - 1) * (q - 1)
e = 65537
d = pow(e, -1, phi)

# Шаг 4: Подпись сообщения "1234"
msg_hash = int.from_bytes(hashlib.sha256(message.encode()).digest(), 'big')
signature = pow(msg_hash, d, n)

# Результат в HEX
print(f"Digital Signature (Hex):\n{hex(signature)[2:]}")
