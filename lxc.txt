import hashlib
import random
from cryptography.hazmat.primitives import serialization, hashes
from cryptography.hazmat.primitives.asymmetric import padding, utils

# --- 1. ПАРАМЕТРЫ (КОТОРЫЕ МЫ ВЗЛОМАЛИ) ---
USERNAME = "mgkrgegk"
MESSAGE = "1234"      # Попробуй также "1234\n" если не сработает
ENDIAN = 'big'        # Подтверждено
Q_MODE = 'SingleHash' # Подтверждено

# --- 2. ВОССТАНОВЛЕНИЕ КЛЮЧА ---
seed_str = f"{USERNAME}_lovenote_2026_valentine"
seed_bytes = seed_str.encode()

def is_prime(n, k=40):
    if n <= 1: return False
    if n <= 3: return True
    if n % 2 == 0: return False
    r, d = 0, n - 1
    while d % 2 == 0: r += 1; d //= 2
    for _ in range(k):
        a = random.randint(2, n - 2)
        x = pow(a, d, n)
        if x == 1 or x == n - 1: continue
        for _ in range(r - 1):
            x = pow(x, 2, n)
            if x == n - 1: break
        else: return False
    return True

def find_next_prime(n):
    if n % 2 == 0: n += 1
    while not is_prime(n): n += 2
    return n

# Генерация P
h_p = hashlib.sha256(seed_bytes).digest()
p = find_next_prime(int.from_bytes(h_p, ENDIAN))

# Генерация Q (SingleHash)
h_q = hashlib.sha256(seed_bytes + b"pki").digest()
q = find_next_prime(int.from_bytes(h_q, ENDIAN))

n = p * q
phi = (p - 1) * (q - 1)
e = 65537
d = pow(e, -1, phi)

print(f"[*] Ключ восстановлен. Генерируем варианты для: '{MESSAGE}'")

# --- 3. ВАРИАНТЫ ПОДПИСИ ---

def to_hex(val):
    return format(val, '0128x')

# Вариант A: PKCS#1 v1.5 (Стандарт)
# S = PKCS1_Pad(Hash(m))^d mod n
h_msg = hashlib.sha256(MESSAGE.encode()).digest()
prefix = b'\x30\x31\x30\x0d\x06\x09\x60\x86\x48\x01\x65\x03\x04\x02\x01\x05\x00\x04\x20'
pad_len = 64 - 3 - len(prefix) - len(h_msg)
block = b'\x00\x01' + (b'\xff' * pad_len) + b'\x00' + prefix + h_msg
sig_pkcs = pow(int.from_bytes(block, 'big'), d, n)

# Вариант B: Raw RSA (Big Endian)
# S = Hash(m)^d mod n
m_int = int.from_bytes(h_msg, 'big')
sig_raw_be = pow(m_int, d, n)

# Вариант C: Raw RSA (Little Endian Output)
# Бывает в C++ реализациях: байты результата развернуты
sig_bytes = sig_raw_be.to_bytes(64, 'big')
sig_raw_le = int.from_bytes(sig_bytes, 'little')

# Вариант D: RSA-PSS (Более современный стандарт)
# Используем библиотеку для PSS, так как вручную сложно
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives.asymmetric import rsa
# Создаем объект ключа для библиотеки
private_key = rsa.RSAPrivateNumbers(
    p=p, q=q, d=d, dmp1=d%(p-1), dmq1=d%(q-1), iqmp=pow(q,-1,p),
    public_numbers=rsa.RSAPublicNumbers(e, n)
).private_key(default_backend())

try:
    sig_pss_bytes = private_key.sign(
        MESSAGE.encode(),
        padding.PSS(mgf=padding.MGF1(hashes.SHA256()), salt_length=padding.PSS.MAX_LENGTH),
        hashes.SHA256()
    )
    sig_pss = sig_pss_bytes.hex()
except:
    sig_pss = "Ошибка генерации PSS"

# Вариант E: Textbook RSA (Без хэша)
# S = int(message_bytes)^d mod n
m_textbook = int.from_bytes(MESSAGE.encode(), 'big')
sig_textbook = pow(m_textbook, d, n)


print("\n=== ПОПРОБУЙ ЭТИ ВАРИАНТЫ ПО ОЧЕРЕДИ ===")
print(f"1. PKCS#1 v1.5 (Самый частый стандарт):\n{to_hex(sig_pkcs)}")
print(f"\n2. Raw RSA (Просто хэш в степень):\n{to_hex(sig_raw_be)}")
print(f"\n3. RSA-PSS (Современный стандарт):\n{sig_pss}")
print(f"\n4. Raw RSA Little-Endian (Перевернутые байты):\n{format(sig_raw_le, '0128x')}")
print(f"\n5. Textbook RSA (Без хэширования, просто текст):\n{to_hex(sig_textbook)}")

-----BEGIN PRIVATE KEY-----
MIIBUQIBADANBgkqhkiG9w0BAQEFAASCATswggE3AgEAAkA4wvUChmqa9BWA/s99
q2z0OMxVEuDZ8esFuQGJgzfhFrdnmTTJ6APRg2v8xBlxLIghPFZIwEx/VXcqk2Xf
A9FDAgMBAAECQBzoniR1FSJqIfGa1U5p2onfy6Gghcg6f7pgaToCDJmkkPJrnTFg
yEX9TJnQDmoGtC94hXLXWhQWIOHhipl7vNECIEqMnfiP56WFh0qdmAmCBJX4gjww
LPd68EY+WeUi6divAiEAwureZmrzJf7BCc1GC6djuN1rkoAMnTGNkor8EJCcja0C
IEHQwUqHqagtKdNLLMYAHpJUko4WrixTQjuRooWz/CYLAiA39vnOTEzuDtxcNR00
gWZHkQOu96cnhy/P8Kn5E5xvrQIgHo+Vz5gwKn3Mq0SIY7vAZ3bSBuwcF3Mx4KwS
vsRnhZE=
-----END PRIVATE KEY-----

-----BEGIN PUBLIC KEY-----
MFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBAICyTyHQxpUuXHaI13bsS3hhMlAH7Oom
fthYPpBmb898d4FtfJCwx7XQWW9pL4Fw5DUFuD5EBcgMGiOIigdP3m8CAwEAAQ==
-----END PUBLIC KEY-----
