import hashlib

def is_prime(n):
    """Быстрая проверка на простоту (тест Миллера — Рабина)."""
    if n < 2: return False
    if n % 2 == 0: return n == 2
    d = n - 1
    s = 0
    while d % 2 == 0:
        d //= 2
        s += 1
    # Достаточно нескольких раундов для 256-битных чисел
    for a in [2, 3, 5, 7, 11, 13, 17, 19, 23]:
        if n <= a: break
        x = pow(a, d, n)
        if x == 1 or x == n - 1:
            continue
        for _ in range(s - 1):
            x = pow(x, 2, n)
            if x == n - 1:
                break
        else:
            return False
    return True

def find_next_prime(n):
    """Ищет ближайшее простое число, начиная с n (как в логах)."""
    if n % 2 == 0: n += 1
    while not is_prime(n):
        n += 2
    return n

# Данные из запроса
username = "admin"
message = "1234"
seed_pattern = f"{username}_lovenote_2026_valentine"
seed_bytes = seed_pattern.encode()

# 1. Извлекаем P (Prime derivation step 1)
hash_p = hashlib.sha256(seed_bytes).digest()
start_p = int.from_bytes(hash_p, 'big')
p = find_next_prime(start_p)

# 2. Извлекаем Q (Prime derivation step 2)
# Согласно логам: SHA256(seed + b"pki")
hash_q = hashlib.sha256(seed_bytes + b"pki").digest()
start_q = int.from_bytes(hash_q, 'big')
q = find_next_prime(start_q)

# 3. Генерация RSA ключей
n = p * q
phi = (p - 1) * (q - 1)
e = 65537
d = pow(e, -1, phi) # Приватная экспонента

# 4. Подпись сообщения (Message Signing)
# Хэшируем само сообщение "1234"
msg_hash = hashlib.sha256(message.encode()).digest()
msg_int = int.from_bytes(msg_hash, 'big')

# Вычисляем подпись: S = Hash^d mod n
signature_int = pow(msg_int, d, n)

# Вывод результата в HEX (как требуется для формы)
signature_hex = hex(signature_int)[2:] # Убираем '0x'
print(f"Username: {username}")
print(f"Message: {message}")
print(f"Digital Signature (Hex):\n{signature_hex}")
