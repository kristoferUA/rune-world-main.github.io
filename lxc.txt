import hashlib
import base64
from cryptography.hazmat.primitives import serialization

# --- 1. ТВОИ ИЗВЕСТНЫЕ ДАННЫЕ ---
USERNAME = "mgkrgegk"
# Твой публичный ключ со скриншота (я переписал его точно)
REAL_PUB_KEY = b"""-----BEGIN PUBLIC KEY-----
MFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBAICyTyHQxpUuXHaI13bsS3hhMlAH7Oom
fthYPpBmb898d4FtfJCwx7XQWW9pL4Fw5DUFuD5EBcgMGiOIigdP3m8CAwEAAQ==
-----END PUBLIC KEY-----"""

# Извлекаем "настоящий" модуль N из ключа для сверки
try:
    pub_obj = serialization.load_pem_public_key(REAL_PUB_KEY)
    REAL_N = pub_obj.public_numbers().n
    print(f"[*] Целевой модуль N (из ключа): {hex(REAL_N)[:30]}...")
except Exception as e:
    print(f"[!] Ошибка чтения ключа: {e}")
    exit()

# --- 2. ЭМУЛЯЦИЯ ЛОГИКИ СЕРВЕРА ---
SEED_STRING = f"{USERNAME}_lovenote_2026_valentine"

# Вспомогательные функции математики
def is_prime(n):
    if n < 2: return False
    if n == 2 or n == 3: return True
    if n % 2 == 0: return False
    d, s = n - 1, 0
    while d % 2 == 0:
        d //= 2
        s += 1
    for a in [2, 3, 5, 7, 11, 13, 17, 19, 23]:
        x = pow(a, d, n)
        if x == 1 or x == n - 1: continue
        for _ in range(s - 1):
            x = pow(x, 2, n)
            if x == n - 1: break
        else: return False
    return True

def find_next_prime(n):
    if n % 2 == 0: n += 1
    while not is_prime(n): n += 2
    return n

print(f"[*] Проверяем генерацию для сида: '{SEED_STRING}'")

# --- 3. ПЕРЕБОР ВАРИАНТОВ ГЕНЕРАЦИИ ---
# Нам нужно найти комбинацию, которая даст тот же N
found = False

# Варианты интерпретации байтов (Big Endian - стандарт, Little - редкость, но бывает)
byte_orders = ['big', 'little']

# Варианты логики Q (как трактовать логи)
# Log 1: Modifying seed with PKI-related constant (SHA256(seed + b"pki"))
# Log 2: Hashing modified seed with SHA256
q_modes = [
    "DoubleHash", # Сначала хэш (seed+pki), потом ХЭШ от этого результата
    "SingleHash", # Просто хэш (seed+pki), игнорируя вторую строку лога
    "ConcatHash"  # Хэш от (seed + hash(seed+pki))
]

for order in byte_orders:
    for mode in q_modes:
        print(f"   Проверка [Endian: {order}, Mode: {mode}]...", end="")
        
        # Генерация P (она везде одинакова - SHA256(seed))
        h_p = hashlib.sha256(SEED_STRING.encode()).digest()
        p_cand = find_next_prime(int.from_bytes(h_p, order))
        
        # Генерация Q
        q_cand = 0
        if mode == "DoubleHash":
            # SHA256( SHA256(seed + "pki") )
            step1 = hashlib.sha256(SEED_STRING.encode() + b"pki").digest()
            step2 = hashlib.sha256(step1).digest()
            q_cand = find_next_prime(int.from_bytes(step2, order))
            
        elif mode == "SingleHash":
            # SHA256( seed + "pki" )
            step1 = hashlib.sha256(SEED_STRING.encode() + b"pki").digest()
            q_cand = find_next_prime(int.from_bytes(step1, order))
            
        elif mode == "ConcatHash":
            # SHA256( seed + SHA256(seed+"pki") )
            mod = hashlib.sha256(SEED_STRING.encode() + b"pki").digest()
            step2 = hashlib.sha256(SEED_STRING.encode() + mod).digest()
            q_cand = find_next_prime(int.from_bytes(step2, order))

        # Сверка
        calc_n = p_cand * q_cand
        
        if calc_n == REAL_N:
            print(" ЕСТЬ КОНТАКТ! ✅")
            print(f"\n[!] АЛГОРИТМ НАЙДЕН:")
            print(f"    Byte Order: {order}")
            print(f"    Q Generation: {mode}")
            found = True
            break
        else:
            print(" мимо.")
            
    if found: break

if not found:
    print("\n[X] Ни один вариант не совпал с твоим публичным ключом.")
    print("Возможные причины:")
    print("1. В сиде используется не просто юзернейм (например, mgkrgegk_lovenote... а может mgkrgegk@lovenote.com?)")
    print("2. Странная кодировка (не UTF-8).")

-----BEGIN PRIVATE KEY-----
MIIBUQIBADANBgkqhkiG9w0BAQEFAASCATswggE3AgEAAkA4wvUChmqa9BWA/s99
q2z0OMxVEuDZ8esFuQGJgzfhFrdnmTTJ6APRg2v8xBlxLIghPFZIwEx/VXcqk2Xf
A9FDAgMBAAECQBzoniR1FSJqIfGa1U5p2onfy6Gghcg6f7pgaToCDJmkkPJrnTFg
yEX9TJnQDmoGtC94hXLXWhQWIOHhipl7vNECIEqMnfiP56WFh0qdmAmCBJX4gjww
LPd68EY+WeUi6divAiEAwureZmrzJf7BCc1GC6djuN1rkoAMnTGNkor8EJCcja0C
IEHQwUqHqagtKdNLLMYAHpJUko4WrixTQjuRooWz/CYLAiA39vnOTEzuDtxcNR00
gWZHkQOu96cnhy/P8Kn5E5xvrQIgHo+Vz5gwKn3Mq0SIY7vAZ3bSBuwcF3Mx4KwS
vsRnhZE=
-----END PRIVATE KEY-----

-----BEGIN PUBLIC KEY-----
MFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBAICyTyHQxpUuXHaI13bsS3hhMlAH7Oom
fthYPpBmb898d4FtfJCwx7XQWW9pL4Fw5DUFuD5EBcgMGiOIigdP3m8CAwEAAQ==
-----END PUBLIC KEY-----
