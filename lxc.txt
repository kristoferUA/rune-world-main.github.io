import hashlib
from Crypto.Util.number import isPrime, inverse
from Crypto.PublicKey import RSA
from Crypto.Signature import pkcs1_15
from Crypto.Hash import SHA256

def get_next_prime(n):
    # Лог говорит: "Checking consecutive integers..." 
    # Это значит n, n+1, n+2...
    while not isPrime(n):
        n += 1
    return n

# 1. ПАРАМЕТРЫ ИЗ ЛОГОВ
username = "admin"
seed = f"{username}_lovenote_2026_valentine".encode() #

# Вычисляем p
p_hash = hashlib.sha256(seed).digest()
p = get_next_prime(int.from_bytes(p_hash, 'big'))

# Вычисляем q (двойное хэширование согласно логу)
#
modified_seed = hashlib.sha256(seed + b"pki").digest()
q_hash = hashlib.sha256(modified_seed).digest()
q = get_next_prime(int.from_bytes(q_hash, 'big'))

# Собираем RSA (он получится 512-битным, что и есть "ложь" про 2048)
n = p * q
e = 65537
phi = (p - 1) * (q - 1)
d = inverse(e, phi)
key = RSA.construct((n, e, d, p, q))

# 2. ПОДПИСЬ ПРАВИЛЬНОГО СООБЩЕНИЯ
# Важно: используй именно то сообщение, которое требует форма!
msg_text = "give_me_flag" 
h = SHA256.new(msg_text.encode())
signature = pkcs1_15.new(key).sign(h)

print(f"\n[*] Ключ RSA-{key.size_in_bits()} сгенерирован.")
print(f"[*] Сообщение: {msg_text}")
print("-" * 50)
print(f"HEX ПОДПИСЬ ДЛЯ ВСТАВКИ:\n{signature.hex()}")
print("-" * 50)
