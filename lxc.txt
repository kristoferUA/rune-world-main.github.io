import hashlib
from Crypto.Util.number import isPrime, inverse
from Crypto.PublicKey import RSA
from Crypto.Signature import pkcs1_15
from Crypto.Hash import SHA256

def get_next_prime(n):
    # Лог: "Checking consecutive integers until a valid prime is reached"
    while not isPrime(n):
        n += 1
    return n

def get_signature(q_val):
    username = "admin"
    seed_str = f"{username}_lovenote_2026_valentine"
    seed = seed_str.encode()
    
    # p вычисляется по логу: SHA256(seed) -> int -> next_prime
    p_hash = hashlib.sha256(seed).digest()
    p = get_next_prime(int.from_bytes(p_hash, 'big'))
    
    # Сборка RSA-512 (т.к. p и q_val по 256 бит)
    n = p * q_val
    e = 65537
    # ИСПРАВЛЕНО: используем q_val вместо q
    phi = (p - 1) * (q_val - 1)
    d = inverse(e, phi)
    key = RSA.construct((n, e, d, p, q_val))
    
    # Подпись сообщения "give_me_flag"
    msg = "give_me_flag"
    h = SHA256.new(msg.encode())
    return pkcs1_15.new(key).sign(h).hex()

# --- ВАРИАНТЫ ГЕНЕРАЦИИ Q ---
username = "admin"
seed = f"{username}_lovenote_2026_valentine".encode()
h1_bin = hashlib.sha256(seed + b"pki").digest()
h1_hex = hashlib.sha256(seed + b"pki").hexdigest().encode()

# 1. Double Binary: H(H(seed + "pki"))
q1 = get_next_prime(int.from_bytes(hashlib.sha256(h1_bin).digest(), 'big'))

# 2. Concat Binary: H(seed + H(seed + "pki"))
q2 = get_next_prime(int.from_bytes(hashlib.sha256(seed + h1_bin).digest(), 'big'))

# 3. Double Hex: H(Hex(H(seed + "pki")))
q3 = get_next_prime(int.from_bytes(hashlib.sha256(h1_hex).digest(), 'big'))

# 4. Concat Hex: H(seed + Hex(H(seed + "pki")))
q4 = get_next_prime(int.from_bytes(hashlib.sha256(seed + h1_hex).digest(), 'big'))

print("\n[*] Целевое сообщение: give_me_flag")
print("-" * 65)
print(f"Вариант 1 (Double Binary): {get_signature(q1)}")
print(f"Вариант 2 (Concat Binary): {get_signature(q2)}")
print(f"Вариант 3 (Double Hex):    {get_signature(q3)}")
print(f"Вариант 4 (Concat Hex):    {get_signature(q4)}")
print("-" * 65)
