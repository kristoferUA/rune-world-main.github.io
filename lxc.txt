import hashlib
from Crypto.Util.number import isPrime, inverse
from Crypto.PublicKey import RSA
from Crypto.Signature import pkcs1_15
from Crypto.Hash import SHA256

def get_next_prime(n):
    # Лог: "Checking consecutive integers until a valid prime is reached"
    while not isPrime(n):
        n += 1
    return n

def get_signature(q_val):
    username = "admin"
    seed = f"{username}_lovenote_2026_valentine".encode()
    
    # p всегда вычисляется одинаково
    p_hash = hashlib.sha256(seed).digest()
    p = get_next_prime(int.from_bytes(p_hash, 'big'))
    
    # Сборка ключа (p и q по 256 бит дают n = 512 бит)
    n = p * q_val
    e = 65537
    d = inverse(e, (p - 1) * (q - 1))
    key = RSA.construct((n, e, d, p, q_val))
    
    # Подпись правильного сообщения
    msg = "give_me_flag"
    h = SHA256.new(msg.encode())
    return pkcs1_15.new(key).sign(h).hex()

# --- ПОДГОТОВКА КОМБИНАЦИЙ Q ИЗ ЛОГОВ ---
username = "admin"
seed = f"{username}_lovenote_2026_valentine".encode()
h1_bin = hashlib.sha256(seed + b"pki").digest()
h1_hex = hashlib.sha256(seed + b"pki").hexdigest().encode()

# 1. Двойной бинарный хэш: H(H(seed + "pki"))
q1 = get_next_prime(int.from_bytes(hashlib.sha256(h1_bin).digest(), 'big'))

# 2. Склеивание с бинарным хэшем: H(seed + H(seed + "pki"))
q2 = get_next_prime(int.from_bytes(hashlib.sha256(seed + h1_bin).digest(), 'big'))

# 3. Хэш от Hex-строки: H(Hex(H(seed + "pki")))
q3 = get_next_prime(int.from_bytes(hashlib.sha256(h1_hex).digest(), 'big'))

# 4. Склеивание с Hex-строкой: H(seed + Hex(H(seed + "pki")))
q4 = get_next_prime(int.from_bytes(hashlib.sha256(seed + h1_hex).digest(), 'big'))

print(f"\n[*] Сообщение: give_me_flag")
print("-" * 60)
print(f"Вариант 1 (Double Binary): {get_signature(q1)}")
print(f"Вариант 2 (Concat Binary): {get_signature(q2)}")
print(f"Вариант 3 (Double Hex):    {get_signature(q3)}")
print(f"Вариант 4 (Concat Hex):    {get_signature(q4)}")
print("-" * 60)
