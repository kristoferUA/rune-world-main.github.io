import hashlib
import random
from cryptography.hazmat.primitives import serialization

# --- ВХОДНЫЕ ДАННЫЕ (Твой эталон) ---
TARGET_USERNAME = "mgkrgegk"
TARGET_PUB_KEY = b"""-----BEGIN PUBLIC KEY-----
MFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBAICyTyHQxpUuXHaI13bsS3hhMlAH7Oom
fthYPpBmb898d4FtfJCwx7XQWW9pL4Fw5DUFuD5EBcgMGiOIigdP3m8CAwEAAQ==
-----END PUBLIC KEY-----"""

# Цель атаки
ADMIN_USERNAME = "admin"
MESSAGE = "1234"

# --- ЛОГИКА ---
def get_n_from_pem(pem_bytes):
    key = serialization.load_pem_public_key(pem_bytes)
    return key.public_numbers().n

def is_prime(n, k=20):
    if n <= 1: return False
    if n <= 3: return True
    if n % 2 == 0: return False
    r, d = 0, n - 1
    while d % 2 == 0: r += 1; d //= 2
    for _ in range(k):
        a = random.randint(2, n - 2)
        x = pow(a, d, n)
        if x == 1 or x == n - 1: continue
        for _ in range(r - 1):
            x = pow(x, 2, n)
            if x == n - 1: break
        else: return False
    return True

def find_next_prime(n):
    if n % 2 == 0: n += 1
    while not is_prime(n): n += 2
    return n

def generate_keypair(username, endian, q_mode):
    seed_str = f"{username}_lovenote_2026_valentine"
    seed_bytes = seed_str.encode()
    
    # 1. Generate P
    h_p = hashlib.sha256(seed_bytes).digest()
    p = find_next_prime(int.from_bytes(h_p, endian))
    
    # 2. Generate Q
    if q_mode == "DoubleHash":
        # Log: Modifying seed... (SHA256(seed + "pki"))
        # Log: Hashing modified seed...
        step1 = hashlib.sha256(seed_bytes + b"pki").digest()
        h_q = hashlib.sha256(step1).digest()
        q = find_next_prime(int.from_bytes(h_q, endian))
    elif q_mode == "SingleHash":
         # Если "Hashing modified seed" это просто описание действия
        h_q = hashlib.sha256(seed_bytes + b"pki").digest()
        q = find_next_prime(int.from_bytes(h_q, endian))
    
    n = p * q
    return n, p, q

# --- ЗАПУСК ПОДБОРА ---
target_n = get_n_from_pem(TARGET_PUB_KEY)
print(f"[*] Целевой модуль (User: {TARGET_USERNAME}): {hex(target_n)[:30]}...")

found_settings = None

# Перебираем варианты (Эндианность + Логика Q)
for endian in ['big', 'little']:
    for q_mode in ['DoubleHash', 'SingleHash']:
        print(f"Проверка: Endian={endian}, Q={q_mode}...", end="")
        calc_n, _, _ = generate_keypair(TARGET_USERNAME, endian, q_mode)
        
        if calc_n == target_n:
            print(" УСПЕХ! СОВПАДЕНИЕ!")
            found_settings = (endian, q_mode)
            break
        else:
            print(" мимо.")
    if found_settings: break

if not found_settings:
    print("\n[!] Не удалось воспроизвести ключ. Возможно, есть 'соль' или username обрабатывается иначе (например, .lower()).")
    exit()

# --- ГЕНЕРАЦИЯ ДЛЯ АДМИНА ---
print("\n" + "="*40)
print(f"[*] Генерируем ключ для {ADMIN_USERNAME} с правильными настройками...")
best_endian, best_q_mode = found_settings

# Генерируем секретные простые числа для админа
_, p_admin, q_admin = generate_keypair(ADMIN_USERNAME, best_endian, best_q_mode)

n_admin = p_admin * q_admin
e = 65537
phi = (p_admin - 1) * (q_admin - 1)
d_admin = pow(e, -1, phi)

print(f"[*] Приватный ключ Admin (d) найден!")

# ПОДПИСЬ (PKCS#1 v1.5 Standard)
# Это единственный стандарт, который примет валидатор публичного ключа
def sign_pkcs1(msg, d, n):
    h = hashlib.sha256(msg.encode()).digest()
    prefix = b'\x30\x31\x30\x0d\x06\x09\x60\x86\x48\x01\x65\x03\x04\x02\x01\x05\x00\x04\x20'
    pad_len = 64 - 3 - len(prefix) - len(h)
    padding = b'\x00\x01' + (b'\xff' * pad_len) + b'\x00'
    block = padding + prefix + h
    m_int = int.from_bytes(block, 'big') # Подпись всегда BigEndian по стандарту RSA
    s = pow(m_int, d, n)
    return format(s, '0128x')

sig = sign_pkcs1(MESSAGE, d_admin, n_admin)

print(f"\nВОТ ТВОЯ ПОДПИСЬ ДЛЯ ADMIN (1234):\n{sig}")
print("="*40)

-----BEGIN PRIVATE KEY-----
MIIBUQIBADANBgkqhkiG9w0BAQEFAASCATswggE3AgEAAkA4wvUChmqa9BWA/s99
q2z0OMxVEuDZ8esFuQGJgzfhFrdnmTTJ6APRg2v8xBlxLIghPFZIwEx/VXcqk2Xf
A9FDAgMBAAECQBzoniR1FSJqIfGa1U5p2onfy6Gghcg6f7pgaToCDJmkkPJrnTFg
yEX9TJnQDmoGtC94hXLXWhQWIOHhipl7vNECIEqMnfiP56WFh0qdmAmCBJX4gjww
LPd68EY+WeUi6divAiEAwureZmrzJf7BCc1GC6djuN1rkoAMnTGNkor8EJCcja0C
IEHQwUqHqagtKdNLLMYAHpJUko4WrixTQjuRooWz/CYLAiA39vnOTEzuDtxcNR00
gWZHkQOu96cnhy/P8Kn5E5xvrQIgHo+Vz5gwKn3Mq0SIY7vAZ3bSBuwcF3Mx4KwS
vsRnhZE=
-----END PRIVATE KEY-----

-----BEGIN PUBLIC KEY-----
MFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBAICyTyHQxpUuXHaI13bsS3hhMlAH7Oom
fthYPpBmb898d4FtfJCwx7XQWW9pL4Fw5DUFuD5EBcgMGiOIigdP3m8CAwEAAQ==
-----END PUBLIC KEY-----
